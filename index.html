<!DOCTYPE html>
<html>
<head>
    <title>XML Tool</title>
    <link rel="stylesheet" data-name="vs/editor/editor.main" href="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs/editor/editor.main.min.css">
    <style>
        * { box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            transition: background 0.3s;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 0;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            transition: background 0.3s, color 0.3s;
        }
        h1 { 
            margin: 0;
            color: white;
            font-size: 20px;
            font-weight: 600;
        }
        .top-menu {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 12px 30px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            margin: 0 auto 0 auto;
            max-width: 1400px;
            border-radius: 0;
            border-bottom: 2px solid #e0e0e0;
        }
        .menu-items {
            display: flex;
            gap: 8px;
        }
        .menu-item {
            padding: 8px 20px;
            background: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            border-radius: 0;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #666;
            transition: all 0.2s;
        }
        .menu-item:hover {
            color: #667eea;
            transform: none;
            box-shadow: none;
        }
        .menu-item.active {
            font-weight: 600;
            color: #667eea;
            border-bottom-color: #667eea;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        body.dark .top-menu {
            background: rgba(0, 0, 0, 0.55);
            border-bottom: 2px solid #000000;
        }
        body.dark .menu-item {
            color: #999;
        }
        body.dark .menu-item:hover {
            color: #667eea;
        }
        body.dark .menu-item.active {
            font-weight: 600;
            color: #667eea;
            border-bottom-color: #667eea;
        }
        .theme-toggle {
            background: transparent;
            padding: 8px 12px;
            font-size: 18px;
            cursor: pointer;
            border: none;
            transition: all 0.2s;
            border-radius: 8px;
            color: #666;
        }
        .theme-toggle:hover {
            background: rgba(102, 126, 234, 0.1);
            color: #667eea;
            transform: none !important;
            box-shadow: none !important;
        }
        body.dark .theme-toggle {
            color: #999;
        }
        body.dark .theme-toggle:hover {
            background: rgba(102, 126, 234, 0.2);
            color: #667eea;
        }
        body.dark {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        }
        body.dark .container {
            background: #0f3460;
            color: #e0e0e0;
        }
        body.dark h1 {
            color: #e0e0e0;
        }
        body.dark .editor-label {
            color: #e0e0e0;
        }
        body.dark .output-title {
            color: #667eea;
        }

        body.dark .editor-container {
            border-color: #1a1a2e;
        }
        body.dark .counterpart-buttons {
            border-top-color: #1a1a2e;
        }
        body.dark .counterpart-btn {
            background: #1a1a2e;
            color: #e0e0e0;
            border-color: #1a1a2e;
        }
        body.dark .counterpart-btn:hover {
            background: #16213e;
            border-color: #667eea;
        }
        body.dark .counterpart-btn.active {
            background: #667eea;
            color: white;
        }
        .editor-container {
            width: 100%;
            height: 300px;
            border: 2px solid #e0e0e0;
            overflow: hidden;
            margin-bottom: 15px;
        }
        #output-editor {
            height: 800px;
        }
        .editor-label {
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 8px;
            color: #333;
        }
        textarea { 
            width: 100%;
            height: 200px;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 13px;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            resize: vertical;
            transition: border-color 0.3s;
        }
        textarea:focus {
            outline: none;
            border-color: #667eea;
        } 
            width: 100%;
            height: 200px;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 13px;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            resize: vertical;
            transition: border-color 0.3s;
        }
        textarea:focus {
            outline: none;
            border-color: #667eea;
        }
        .button-group {
            margin: 15px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        button { 
            padding: 10px 20px;
            margin: 5px 5px 5px 0;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }
        .button-group button {
            background: #667eea;
            color: white;
        }
        .button-group button:hover {
            background: #5568d3;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        .save-btn {
            background: #28a745 !important;
        }
        .save-btn:hover {
            background: #218838 !important;
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.4) !important;
        }
        .load-btn {
            background: #dc3545 !important;
        }
        .load-btn:hover {
            background: #c82333 !important;
            box-shadow: 0 4px 12px rgba(220, 53, 69, 0.4) !important;
        }
        .counterpart-buttons { 
            margin: 25px 0 15px 0;
            padding-top: 20px;
            border-top: 2px solid #f0f0f0;
        }
        .counterpart-btn { 
            background: #f8f9fa;
            color: #333;
            border: 2px solid #e0e0e0;
        }
        .counterpart-btn:hover { 
            background: #e9ecef;
            border-color: #667eea;
        }
        .counterpart-btn.active { 
            background: #667eea;
            color: white;
            border-color: #667eea;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }
        .output-title { 
            font-weight: 600;
            font-size: 16px;
            margin: 15px 0 8px 0;
            color: #667eea;
        }
        .copy-btn {
            background: #6c757d;
            color: white;
            padding: 6px 12px;
            font-size: 12px;
            margin: 10px 0;
        }
        .copy-btn:hover {
            background: #5a6268;
            box-shadow: 0 2px 8px rgba(108, 117, 125, 0.4);
        }
        .output-actions {
            display: none;
            justify-content: flex-end;
            align-items: center;
            margin: 10px 0;
            gap: 10px;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            align-items: center;
        }
        .controls button {
            background: #667eea;
            color: white;
        }
        .controls button:hover {
            background: #5568d3;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        .format-info {
            margin-left: 10px;
            padding: 6px 12px;
            background: #f0f0f0;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            color: #667eea;
        }
        body.dark .format-info {
            background: #1a1a2e;
            color: #667eea;
        }
        .save-counterpart-btn {
            background: #28a745;
            color: white;
            padding: 6px 12px;
            font-size: 12px;
        }
        .save-counterpart-btn:hover {
            background: #218838;
            box-shadow: 0 2px 8px rgba(40, 167, 69, 0.4);
        }
        .output { 
            background: #f8f9fa;
            padding: 15px;
            margin: 10px 0;
            white-space: pre;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 13px;
            overflow-x: auto;
            border-radius: 8px;
            border: 2px solid #e0e0e0;
            min-height: 100px;
            color: #333;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs/loader.min.js"></script>
</head>
<body>
    <div class="top-menu">
        <div class="menu-items">
            <button class="menu-item active" onclick="switchTab('decoder')">XML Decoder</button>
            <button class="menu-item" onclick="switchTab('formatter')">Formatter</button>
        </div>
        <button class="theme-toggle" onclick="toggleTheme()">ðŸŒ™</button>
    </div>
    
    <div class="container">
        <div id="decoder-tab" class="tab-content active">
        <div class="editor-label">Input XML:</div>
        <div id="input-editor" class="editor-container"></div>
        
        <div class="button-group">
            <div>
                <button onclick="decodeBase64()">Decode Counterparts</button>
                <button onclick="clearAll()">Clear</button>
            </div>
            <div>
                <button class="load-btn" onclick="loadXML()">Load</button>
                <button class="save-btn" onclick="saveXML()">Save</button>
            </div>
        </div>
        
        <div id="counterpart-buttons" class="counterpart-buttons"></div>
        <div id="output-title" class="output-title"></div>
        <div class="editor-label" id="output-label" style="display: none;">Output:</div>
        <div id="output-editor" class="editor-container" style="display: none;"></div>
        <div id="output-actions" class="output-actions">
            <button class="copy-btn" onclick="copyToClipboard()">Copy to Clipboard</button>
            <button class="save-counterpart-btn" onclick="saveCounterpart()">Save Counterpart</button>
        </div>
        </div>
        
        <div id="formatter-tab" class="tab-content">
            <div class="controls">
                <button onclick="formatCode()">Format</button>
                <button onclick="clearFormatter()">Clear</button>
            </div>
            <div id="formatter-editor" class="editor-container"></div>
        </div>
    </div>

    <script>
        let decodedCounterparts = [];
        let fullXml = '';
        let inputEditor, outputEditor, formatterEditor;
        let isDark = localStorage.getItem('theme') === 'dark';

        require.config({ paths: { vs: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs' }});
        
        require(['vs/editor/editor.main'], function() {
            inputEditor = monaco.editor.create(document.getElementById('input-editor'), {
                value: '',
                language: 'xml',
                theme: isDark ? 'vs-dark' : 'vs',
                automaticLayout: true,
                minimap: { enabled: true },
                folding: true,
                lineNumbers: 'on',
                scrollBeyondLastLine: false,
                wordWrap: 'on'
            });

            outputEditor = monaco.editor.create(document.getElementById('output-editor'), {
                value: '',
                language: 'xml',
                theme: isDark ? 'vs-dark' : 'vs',
                automaticLayout: true,
                minimap: { enabled: true },
                folding: true,
                lineNumbers: 'on',
                scrollBeyondLastLine: false,
                wordWrap: 'on',
                readOnly: false
            });

            formatterEditor = monaco.editor.create(document.getElementById('formatter-editor'), {
                value: '',
                language: 'plaintext',
                theme: isDark ? 'vs-dark' : 'vs',
                automaticLayout: true,
                minimap: { enabled: true },
                folding: true,
                lineNumbers: 'on',
                scrollBeyondLastLine: false,
                wordWrap: 'on',
                formatOnPaste: true,
                formatOnType: true
            });

            if (isDark) {
                document.body.classList.add('dark');
                document.querySelector('.theme-toggle').textContent = 'â˜€ï¸';
            }

            formatterEditor.onDidChangeModelContent(() => {
                const content = formatterEditor.getValue();
                if (content.trim()) {
                    detectType(content);
                }
            });

            inputEditor.onDidPaste(() => {
                setTimeout(() => {
                    const value = inputEditor.getValue().trimEnd();
                    inputEditor.setValue(value);
                    inputEditor.setPosition({ lineNumber: 1, column: 1 });
                    document.getElementById('counterpart-buttons').innerHTML = '';
                    document.getElementById('counterpart-buttons').style.display = 'none';
                    decodedCounterparts = [];
                    fullXml = '';
                    formatXML();
                }, 0);
            });

            const inputContainer = document.getElementById('input-editor');
            inputContainer.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
            });
            
            inputContainer.addEventListener('drop', async (e) => {
                e.preventDefault();
                e.stopPropagation();
                const files = e.dataTransfer.files;
                if (files.length > 0 && files[0].name.endsWith('.xml')) {
                    const content = await files[0].text();
                    inputEditor.setValue(content);
                    document.getElementById('counterpart-buttons').innerHTML = '';
                    document.getElementById('counterpart-buttons').style.display = 'none';
                    decodedCounterparts = [];
                    fullXml = '';
                    formatXML();
                }
            });
        });

        function formatXML() {
            const input = inputEditor.getValue();
            if (!input.trim()) return;
            try {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(input, 'text/xml');
                const serializer = new XMLSerializer();
                const formatted = serializer.serializeToString(xmlDoc);
                outputEditor.setValue(formatXMLString(formatted));
                document.getElementById('output-title').textContent = 'Formatted XML';
                document.getElementById('output-actions').style.display = 'flex';
                document.getElementById('output-editor').style.display = 'block';
                document.getElementById('output-label').style.display = 'block';
            } catch (e) {
                outputEditor.setValue('Error formatting XML: ' + e.message);
            }
        }

        function formatXMLString(xml) {
            let formatted = '';
            let indent = 0;
            xml = xml.replace(/<\?xml[^?]*\?>\s*/g, '');
            xml.split(/>\s*</).forEach(node => {
                if (node.match(/^\/\w/)) indent--;
                formatted += '  '.repeat(indent) + '<' + node + '>\n';
                if (node.match(/^<?\w[^>]*[^\/]$/)) indent++;
            });
            return formatted.substring(1, formatted.length - 2);
        }

        function decodeBase64() {
            const input = inputEditor.getValue();
            decodedCounterparts = [];
            try {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(input, 'text/xml');
                
                const counterpartNodes = xmlDoc.querySelectorAll('Counterpart, [*|Counterpart]');
                const tempData = [];
                
                for (let node of counterpartNodes) {
                    if (node.textContent.trim()) {
                        try {
                            const decoded = atob(node.textContent.trim());
                            const decodedDoc = parser.parseFromString(decoded, 'text/xml');
                            const docType = decodedDoc.querySelector('DocumentType')?.textContent || 'Unknown';
                            const signingRole = decodedDoc.querySelector('SigningPartyRole')?.textContent;
                            tempData.push({ docType, signingRole, decoded, node, decodedDoc });
                        } catch (e) {}
                    }
                }
                
                const docTypeCounts = {};
                tempData.forEach(d => docTypeCounts[d.docType] = (docTypeCounts[d.docType] || 0) + 1);
                
                tempData.forEach(d => {
                    const label = docTypeCounts[d.docType] > 1 && d.signingRole ? `${d.docType} - ${d.signingRole}` : d.docType;
                    decodedCounterparts.push({ type: label, xml: d.decoded });
                    d.node.textContent = '';
                    while (d.node.firstChild) d.node.removeChild(d.node.firstChild);
                    for (let child of d.decodedDoc.documentElement.childNodes) {
                        d.node.appendChild(xmlDoc.importNode(child, true));
                    }
                });
                
                const serializer = new XMLSerializer();
                fullXml = serializer.serializeToString(xmlDoc);
                displayButtons();
                
                setTimeout(() => {
                    const fullBtn = document.getElementById('btn-full');
                    if (fullBtn) {
                        fullBtn.click();
                    }
                }, 50);
            } catch (e) {
                outputEditor.setValue('Error processing XML: ' + e.message);
                document.getElementById('output-editor').style.display = 'block';
                document.getElementById('output-label').style.display = 'block';
            }
        }

        function displayButtons() {
            const container = document.getElementById('counterpart-buttons');
            container.innerHTML = '';
            container.style.display = 'block';
            
            const fullBtn = document.createElement('button');
            fullBtn.className = 'counterpart-btn';
            fullBtn.id = 'btn-full';
            fullBtn.textContent = 'Full XML';
            fullBtn.onclick = () => {
                setActive('btn-full');
                document.getElementById('output-title').textContent = 'Full XML';
                outputEditor.setValue(formatXMLString(fullXml));
                document.getElementById('output-actions').style.display = 'flex';
                document.getElementById('output-editor').style.display = 'block';
                document.getElementById('output-label').style.display = 'block';
                container.scrollIntoView({ behavior: 'smooth', block: 'start' });
            };
            container.appendChild(fullBtn);
            
            decodedCounterparts.forEach((cp, idx) => {
                const btn = document.createElement('button');
                btn.className = 'counterpart-btn';
                btn.id = 'btn-' + idx;
                btn.textContent = cp.type;
                btn.onclick = () => showCounterpart(idx);
                container.appendChild(btn);
            });
        }

        function setActive(btnId) {
            document.querySelectorAll('.counterpart-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(btnId).classList.add('active');
        }

        function showCounterpart(idx) {
            setActive('btn-' + idx);
            document.getElementById('output-title').textContent = decodedCounterparts[idx].type;
            outputEditor.setValue(formatXMLString(decodedCounterparts[idx].xml));
            document.getElementById('output-actions').style.display = 'flex';
            document.getElementById('output-editor').style.display = 'block';
            document.getElementById('output-label').style.display = 'block';
            document.getElementById('counterpart-buttons').scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        function copyToClipboard() {
            const output = outputEditor.getValue();
            navigator.clipboard.writeText(output).then(() => {
                const btn = event.target;
                const originalText = btn.textContent;
                btn.textContent = 'Copied!';
                setTimeout(() => btn.textContent = originalText, 2000);
            }).catch(e => alert('Failed to copy: ' + e.message));
        }

        function saveCounterpart() {
            const content = outputEditor.getValue();
            const title = document.getElementById('output-title').textContent;
            if (!content.trim()) {
                alert('No content to save');
                return;
            }
            
            if ('showSaveFilePicker' in window) {
                saveCounterpartWithPicker(content, title);
            } else {
                alert('File System Access API not supported in this browser');
            }
        }

        async function saveCounterpartWithPicker(content, title) {
            try {
                const filename = title.replace(/[^a-z0-9]/gi, '-').toLowerCase();
                const handle = await window.showSaveFilePicker({
                    suggestedName: `${filename}-${Date.now()}.xml`,
                    types: [{
                        description: 'XML Files',
                        accept: { 'text/xml': ['.xml'] }
                    }]
                });
                const writable = await handle.createWritable();
                await writable.write(content);
                await writable.close();
                alert('Counterpart saved successfully!');
            } catch (e) {
                if (e.name !== 'AbortError') {
                    alert('Error saving file: ' + e.message);
                }
            }
        }

        function clearAll() {
            inputEditor.setValue('');
            outputEditor.setValue('');
            document.getElementById('output-title').textContent = '';
            document.getElementById('counterpart-buttons').innerHTML = '';
            document.getElementById('counterpart-buttons').style.display = 'none';
            document.getElementById('output-actions').style.display = 'none';
            document.getElementById('output-editor').style.display = 'none';
            document.getElementById('output-label').style.display = 'none';
            decodedCounterparts = [];
            fullXml = '';
        }

        function saveXML() {
            const input = inputEditor.getValue();
            if (!input.trim()) {
                alert('No XML to save');
                return;
            }
            
            if ('showSaveFilePicker' in window) {
                saveWithFilePicker(input);
            } else {
                alert('File System Access API not supported in this browser');
            }
        }

        async function saveWithFilePicker(content) {
            try {
                const handle = await window.showSaveFilePicker({
                    suggestedName: `xml-${Date.now()}.xml`,
                    types: [{
                        description: 'XML Files',
                        accept: { 'text/xml': ['.xml'] }
                    }]
                });
                const writable = await handle.createWritable();
                await writable.write(content);
                await writable.close();
                alert('File saved successfully!');
            } catch (e) {
                if (e.name !== 'AbortError') {
                    alert('Error saving file: ' + e.message);
                }
            }
        }

        function loadXML() {
            if ('showOpenFilePicker' in window) {
                loadWithFilePicker();
            } else {
                alert('File System Access API not supported in this browser');
            }
        }

        async function loadWithFilePicker() {
            try {
                const [handle] = await window.showOpenFilePicker({
                    types: [{
                        description: 'XML Files',
                        accept: { 'text/xml': ['.xml'] }
                    }],
                    multiple: false
                });
                const file = await handle.getFile();
                const content = await file.text();
                inputEditor.setValue(content);
                formatXML();
            } catch (e) {
                if (e.name !== 'AbortError') {
                    alert('Error loading file: ' + e.message);
                }
            }
        }

        function toggleTheme() {
            isDark = !isDark;
            document.body.classList.toggle('dark', isDark);
            inputEditor.updateOptions({ theme: isDark ? 'vs-dark' : 'vs' });
            outputEditor.updateOptions({ theme: isDark ? 'vs-dark' : 'vs' });
            formatterEditor.updateOptions({ theme: isDark ? 'vs-dark' : 'vs' });
            document.querySelector('.theme-toggle').textContent = isDark ? 'â˜€ï¸' : 'ðŸŒ™';
            localStorage.setItem('theme', isDark ? 'dark' : 'light');
        }

        function switchTab(tab) {
            document.querySelectorAll('.menu-item').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            
            if (tab === 'decoder') {
                document.querySelector('.menu-item:nth-child(1)').classList.add('active');
                document.getElementById('decoder-tab').classList.add('active');
            } else {
                document.querySelector('.menu-item:nth-child(2)').classList.add('active');
                document.getElementById('formatter-tab').classList.add('active');
            }
        }

        function detectType(content) {
            const trimmed = content.trim();
            if (trimmed.startsWith('<') || trimmed.startsWith('<?xml')) return 'xml';
            if (trimmed.startsWith('{') || trimmed.startsWith('[')) return 'json';
            return 'yaml';
        }

        function formatCode() {
            const input = formatterEditor.getValue();
            if (!input.trim()) return;

            const type = detectType(input);
            monaco.editor.setModelLanguage(formatterEditor.getModel(), type);

            try {
                let formatted;
                if (type === 'xml') {
                    formatted = formatXMLString(input);
                } else if (type === 'json') {
                    formatted = JSON.stringify(JSON.parse(input), null, 2);
                } else {
                    formatted = formatYAML(input);
                }
                formatterEditor.setValue(formatted);
                formatterEditor.setPosition({ lineNumber: 1, column: 1 });
            } catch (e) {
                alert('Error formatting: ' + e.message);
            }
        }

        function formatYAML(yaml) {
            const lines = yaml.split('\n');
            let formatted = '';
            
            lines.forEach(line => {
                const trimmed = line.trim();
                if (!trimmed || trimmed.startsWith('#')) {
                    formatted += line + '\n';
                    return;
                }
                
                const leadingSpaces = line.match(/^\s*/)[0].length;
                const indent = Math.floor(leadingSpaces / 2);
                formatted += '  '.repeat(indent) + trimmed + '\n';
            });
            
            return formatted.trim();
        }

        function clearFormatter() {
            formatterEditor.setValue('');
            monaco.editor.setModelLanguage(formatterEditor.getModel(), 'plaintext');
        }
    </script>
</body>
</html>
